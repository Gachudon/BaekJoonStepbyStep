'''
코드 출처: https://mong9data.tistory.com/68
문제의 핵심
동적 계획법은 최적화 문제를 해결하는 알고리즘으로서, 아래의 내용을 항상 명심해야
한다.
'전체의 문제'를 '부분 문제'로 잘 나누었는가? 그렇다면 전체 문제를 해결하기 위한
부분 문제의 점화식은 무엇인가?
부분 문제들을 해결하며 얻는 결과값을 메모이제이션하는가?
부분 문제의 점화식은 부분 문제들 사이의 '관계'를 빠짐없이 고려하는가?

위를 바탕으로 했을 때 2293의 문제 핵심은 다음과 같다.
'가치의 합이 k원이 되는 경우의 수'를 구하는 전체의 문제를, '가치의 합이
i(1<=i<=k)원이 되는 경우의 수'를 구하는 부분 문제로 나눈다. 추가적으로 부분
문제를 더욱 세부적으로 나눌 것인데, '특정 동전을 썼을 때 가치의 합이 i원이 되는
경우의 수'를 구하는 부분 문제로 나눈다.
위에서 언급한 문제들을 해결해나가며 메모이제이션을 할 것인데, 시간 제한이
0.5초이며 메모리 제한도 4MB밖에 되지 않기 때문에 하나의 리스트 안에서 덮어
씌우는 식으로 빠르게 해결해나가야 한다.
입출력 예시로 주어진 경우 말고도 다른 예시를 생각해보며 테스팅해봐야 한다.
'''

from sys import stdin
input=stdin.readline

n,k=map(int,input().split())
c=[int(input()) for _ in range(n)]
dp=[0 for _ in range(k+1)] # 합이 i원이 되는 경우의 수를 구하기 위해 리스트 dp에 0을 k+1개 초기화한다. dp[1]은 합이 1원이 되는 경우의 수, dp[2]는 합이 2원이 되는 경우의 수,...,dp[k]는 합이 k원이 되는 경우의 수이다.
dp[0]=1 # dp[0]은 위 논리에 따라 '합이 0원이 되는 경우의 수'가 아니다.

for i in c: # 첫 번째 for 문에서는 각 코인의 종류를 전부 순회한다. 입출력 예시의 경우, 1원-2원-5원 순으로 순회한다.
    for j in range(i,k+1): # dp를 순회하며 특정 가치를 가진 동전을 썼을 때 합이 j원이 되는 경우의 수가 있다면 리스트 dp에 기록하기 위한 for문이다. 만약 동전이 3원 짜리라면 dp[1],dp[2]는 고려할 필요가 없으므로 dp[3]부터 순회한다.
        if j-i>=0:
            dp[j]+=dp[j-i]
'''
먼저 동전 1원일 때를 생각해 보자(i=1). j는 i부터 시작하므로 가장 처음 나오는
j는 1이다. j-i는 1-1이므로 0과 같다. 조건문의 조건에 만족하므로
dp[1]=dp[1]+dp[0]이 된다. dp[1]=0+1이 되는데, 이처럼 동전이 딱 하나만 쓰일
때 dp[0]에 할당해놓은 1을 이용한다. 이것이 line 4에서 설명하지 못한 부분이다.
계속 j가 늘어나도 조건문의 조건 'j-i>=0'이 만족하므로 dp[j]에 dp[j]+dp[j-i]
값이 덮어 씌워진다.

문제는 2원짜리 동전부터다(i=2). j는 2부터 시작하며 j-i=0이므로 조건문의 조건에
만족한다. 그에 따라 dp[2]=dp[2]+dp[0]=1+1이 된다. 이것 또한 2원짜리 동전을
하나만 쓰는 경우를 추가하기 때문에 dp[0]에 할당된 1을 이용했다. dp[3]은
dp[3]+dp[1]인데, 이 얘기는 '1원짜리 동전으로 3원의 합을 만든 경우의 수(1+1+1)'
+ '1원짜리 동전으로 1원의 합을 만든 경우에 2를 더해서 만든 경우의 수(1+2)'라는
것이다.

이러한 과정을 5원짜리 동전까지 모두 마친다면 다음과 같은 리스트가 완성된다.
'''
print(dp[k])